function _ansi() {

    # If command-line arguments
    if [[ -t 0 ]]; then
        input="$*"

    # If standard input
    else
        input=$(cat)
    fi

    # Format backticks as bold
    bold=$(printf '\033[1m')
    normal=$(printf '\033[22m')
    echo "$input" | sed "s/\`\\([^\`]*\\)\`/${bold}\\1${normal}/g"
}

function _search() {

    # In $1 is path to find
    if [[ $# -ne 1 ]]; then
        return
    fi

    # Find any $1 in descendants
    paths=$(find $(pwd) -name "$1" 2> /dev/null)
    if [[ -z "$paths" ]]; then

        # Find any $1 in ancestors
        local dir="$(dirname "$(pwd)")"
        while [[ "$dir" != "/" ]]; do
            paths=$(find "$dir" -maxdepth 1 -name "$1")
            if [[ -z "$paths" ]]; then
                dir=$(dirname "$dir")
            else
                break
            fi
        done
        if [[ -z "$paths" ]]; then

            # Find any $1 relative to `cd`
            pushd "$(cd && pwd)" > /dev/null
            paths=$(find $(pwd) -name "$1" 2> /dev/null)
            popd > /dev/null
        fi
    fi

    # Count paths
    count=$(echo "$paths" | grep -c .)

    # If just one
    if [[ "$count" -eq 1 ]]; then

        # Resolve absolute path to relative path
        realpath --relative-to=. "$(dirname "$paths")"
    fi
}

function _sure() {
    if [[ $# -ne 1 ]]; then
        return 1
    fi
    prompt=$(echo "$1" | _ansi)
    while true; do
        read -p "$prompt [y/N] " -r
        if [[ "${REPLY,,}" =~ ^(y|yes)$ ]]; then
            return 0
        elif [[ "${REPLY,,}" =~ ^(n|no)$ ]]; then
            return 1
        fi
    done
}

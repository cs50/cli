#!/bin/bash

output=$(cat)

regex="make: Nothing to be done for '(.*)'"
if [[ "$output" =~ $regex ]]; then

    # If target is a directory
    if [[ -d "${BASH_REMATCH[1]}" ]]; then
        echo "Cannot run \`make\` on a directory. Did you mean to \`cd ${BASH_REMATCH[1]}\` first?"
        exit
    fi

    # If target ends with .c
    if [[ "${BASH_REMATCH[1]}" == *?.c ]]; then
        base="${BASH_REMATCH[1]%.c}"
        if [[ -n "$base" && ! -d "$base" ]]; then
            echo "Did you mean to \`make ${base}\`?"
            exit
        fi
    fi

fi

regex="No rule to make target '(.*)'"
if [[ "$output" =~ $regex ]]; then

    # If no .c file for target
    c="${BASH_REMATCH[1]}.c"
    if [[ ! -f "$c" ]]; then

        # Search recursively for .c file
        pushd "$(cd && pwd)" > /dev/null
        paths=$(find $(pwd) -name "$c" 2> /dev/null)
        lines=$(echo "$paths" | grep -c .)
        popd > /dev/null
        echo -n "There isn't a file called \`${c}\` in your current directory."
        if [[ "$lines" -eq 1 ]]; then # If unambiguous
            d=$(realpath --relative-to=. "$(dirname "$paths")")
            echo " Did you mean to \`cd ${d}\` first?"
        else
            echo
        fi
        exit 
    fi
fi

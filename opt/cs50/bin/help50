#!/bin/bash

# If root
if [[ `id -u` -eq 0 ]]; then
    exit 1
fi

function _disable() {
    touch /var/tmp/help50.lock
}

function _is-enabled() {
    if [[ -f /var/tmp/help50.lock ]]; then
        echo disabled
        return 1
    else
        echo enabled
        return 0
    fi
}

function _enable() {
    rm --force /var/tmp/help50.lock
}

function _start() {

    # If already helping
    if [[ -n "$HELP50" ]]; then
        return 0
    fi

    # PID of parent shell to help
    local HELP50=$PPID

    # Start `script` in background, using ; instead of && for command,
    # else if user logs out (as via ctl-d) after a non-0 command, bash exits with 127
    set -o monitor
    HELP50=$HELP50 script --command "bash --login ; exit 1" --flush --quiet --return /var/tmp/help50.$HELP50.typescript &
    local pid=$!

    # Remember PID of `script`, in case user wants to turn off
    echo $pid > /var/tmp/help50.$HELP50.pid

    # Foreground `script`, without echoing command
    #fg > /dev/null
    wait
    local status=$?

    # No longer helping
    rm --force /var/tmp/help50.$HELP50.*

    # Temporary
    if [[ $status -eq 150 ]]; then
        echo "[$status]"
        echo "Sorry, something's wrong! Please let sysadmins@cs50.harvard.edu know."

    # If `script` was killed, in which case `exit 1` above won't execute
    elif [[ $status -ne 1 ]]; then

        # Without this, prompt ends up below and to right of "Session terminated, killing shell... ...killed."
        echo -e "\r"
        echo "[[$status]]"

    # Else if `script` exited on its own, as via ctl-d or `logout`
    else

        # Kill parent shell, since user presumably wants to exit
        echo "[[[$status]]]"
        kill -SIGHUP $HELP50
    fi
}

function _stop() {
    for pid in /var/tmp/help50.*.pid
    do
        kill -SIGTERM $(cat "$pid")
    done
}

# Parse argument
case "$1" in
    disable)
        _disable
        ;;
    enable)
        _enable
        ;;
    is-enabled)
        _is-enabled
        ;;
    start)
        _start
        ;;
    stop)
        _stop
        ;;
    *)
        echo "Usage: $0 [disable|enable|is-enabled|start|stop]"
        exit 1
        ;;
esac
